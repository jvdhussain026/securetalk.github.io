{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user in the Secure Talk application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the User entity."
        },
        "username": {
          "type": "string",
          "description": "The user's username."
        },
        "email": {
          "type": "string",
          "description": "The user's email address.",
          "format": "email"
        },
        "profilePictureUrl": {
          "type": "string",
          "description": "URL of the user's profile picture.",
          "format": "uri"
        }
      },
      "required": [
        "id",
        "username",
        "email"
      ]
    },
    "Chat": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Chat",
      "type": "object",
      "description": "Represents a chat session between users.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Chat entity."
        },
        "participants": {
          "type": "array",
          "description": "References to Users participating in the chat. (Relationship: Chat N:N User)",
          "items": {
            "type": "string"
          }
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp of when the chat was created.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "participants",
        "createdAt"
      ]
    },
    "Message": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Message",
      "type": "object",
      "description": "Represents a message within a chat.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Message entity."
        },
        "chatId": {
          "type": "string",
          "description": "Reference to the Chat this message belongs to. (Relationship: Chat 1:N Message)"
        },
        "senderId": {
          "type": "string",
          "description": "Reference to the User who sent the message. (Relationship: User 1:N Message)"
        },
        "content": {
          "type": "string",
          "description": "The content of the message."
        },
        "timestamp": {
          "type": "string",
          "description": "Timestamp of when the message was sent.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "chatId",
        "senderId",
        "content",
        "timestamp"
      ]
    },
    "Contact": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Contact",
      "type": "object",
      "description": "Represents a contact in a user's contact list.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Contact entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to the User who owns this contact. (Relationship: User 1:N Contact)"
        },
        "contactUserId": {
          "type": "string",
          "description": "Reference to the User who is the contact. (Relationship: User 1:N Contact)"
        },
        "displayName": {
          "type": "string",
          "description": "The display name for the contact."
        }
      },
      "required": [
        "id",
        "userId",
        "contactUserId",
        "displayName"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profile information.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            }
          ]
        }
      },
      {
        "path": "chats/{chatId}",
        "definition": {
          "entityName": "Chat",
          "schema": {
            "$ref": "#/backend/entities/Chat"
          },
          "description": "Stores chat session information.",
          "params": [
            {
              "name": "chatId",
              "description": "The unique identifier of the chat."
            }
          ]
        }
      },
      {
        "path": "chats/{chatId}/messages/{messageId}",
        "definition": {
          "entityName": "Message",
          "schema": {
            "$ref": "#/backend/entities/Message"
          },
          "description": "Stores messages within a chat session. Includes denormalized 'chatId' for efficient querying.",
          "params": [
            {
              "name": "chatId",
              "description": "The unique identifier of the chat."
            },
            {
              "name": "messageId",
              "description": "The unique identifier of the message."
            }
          ]
        }
      },
      {
        "path": "users/{userId}/contacts/{contactId}",
        "definition": {
          "entityName": "Contact",
          "schema": {
            "$ref": "#/backend/entities/Contact"
          },
          "description": "Stores contact information for a user. Includes 'userId' to ensure that only the user can access their contacts.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "contactId",
              "description": "The unique identifier of the contact."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to ensure security, scalability, and ease of debugging, adhering to the principles of Authorization Independence, Clarity of Intent, DBAC, and QAPs. It leverages denormalization to avoid hierarchical authorization dependencies and structural segregation to maintain homogeneous security postures within collections.\n\n**Authorization Independence:**\n\n*   For `chats/{chatId}/messages/{messageId}`, the `chatId` is present in each message document. While not strictly an authorization field, it allows security rules to efficiently query messages belonging to a specific chat without needing to traverse user relationships. In collaborative scenarios where access to chat messages depends on membership, a 'members' map would need to be denormalized into each message for independent authorization (e.g., `messages/{messageId}.members`).\n*   For `users/{userId}/contacts/{contactId}`, the `userId` is included within the contact document. This enables security rules to directly verify ownership of contacts based on the `userId` field without external lookups.\n\n**Structural Segregation:**\n\n*   The separation of user-specific data (contacts) into `/users/{userId}/contacts/{contactId}` ensures that each collection has a consistent security profile, making rules simpler and more maintainable.\n\n**Access Modeling:**\n\n*   Private data, such as contacts, are stored under path-based ownership (`/users/{userId}/contacts/{contactId}`), which simplifies ownership-based security rules.\n*   Collaborative data (chats and messages) would require a membership map (`members: {uid1: \"role\", uid2: \"role\"}`) to be denormalized per Strategy A into both `chats` and `messages` if access control goes beyond the initial chat participants.\n\n**QAPs (Rules Are Not Filters):**\n\n*   The structure supports secure `list` operations by segregating data based on ownership and access control requirements. For example, listing contacts under `/users/{userId}/contacts` is inherently secure because the query is scoped to a specific user's contacts.\n\n**Invariants:**\n\n*   Ownership of contacts is enforced through the `userId` field, which must match the authenticated user's ID. Timestamps, although present in the schema, would require server-side enforcement via Firestore rules to maintain their integrity.\n\nIn summary, this structure prioritizes Authorization Independence through denormalization, enabling atomic operations and simplifying security rules. It leverages Structural Segregation to maintain homogeneous security postures and supports secure list operations (QAPs)."
  }
}