/**
 * @fileoverview Firestore Security Rules for Secure Talk application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user-specific data
 * while allowing public read access to some collections. All write operations
 * are protected by authorization checks to ensure data integrity and prevent
 * unauthorized modifications.
 *
 * Data Structure:
 * - /users/{userId}: Stores individual user profiles. Only the user can read/write their own profile.
 * - /usernames/{username}: Stores reserved usernames, writeable only on creation.
 * - /team/{userId}: Stores profiles of team members. Only team members can be stored.
 * - /chats/{chatId}: Stores chat session information. Access is based on participants.
 * - /chats/{chatId}/messages/{messageId}: Stores messages within chat sessions. Access is based on chat participants.
 * - /users/{userId}/contacts/{contactId}: Stores a user's contacts. Only the user can manage their own contacts.
 * - /groups/{groupId}: Stores group chat information. Access controlled by group ownership and participants.
 * - /groups/{groupId}/messages/{messageId}: Stores messages within group chats. Access controlled by group participants.
 *
 * Key Security Decisions:
 * - Users can only read and write their own data under /users/{userId}.
 * - Listing users is not allowed to protect user privacy.
 * - Public read access is granted to the /team collection.
 * - No data validation is performed beyond authorization checks in this prototyping phase.
 *
 * Denormalization for Authorization:
 * - The `participants` map in /chats/{chatId} and /groups/{groupId} is crucial for authorization. It directly stores user IDs and their roles, enabling efficient access control without additional reads.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure user profiles. Only the user can read and write their profile data.
     * @path /users/{userId}
     * @allow (create, update, delete) User with matching ID can manage their profile.
     * @deny (create, update, delete) User attempts to manage another user's profile.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures usernames. Only allows a user to create their username once.
     * @path /usernames/{username}
     * @allow (create) User can create their username if the UID matches.
     * @deny (get, list, update, delete) No read, listing, updating, or deletion of usernames.
     * @principle Enforces one-time username creation.
     */
    match /usernames/{username} {
      allow get: if false;
      allow list: if false;
      allow create: if request.auth != null && request.resource.data.uid == request.auth.uid;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure team member profiles. Read access is public, but only authorized users can manage team member data.
     * @path /team/{teamMemberId}
     * @allow (get, list) Public read access to team member profiles.
     * @deny (create, update, delete) Only authenticated team member can manage team member profiles.
     * @principle Restricts write access to authorized users.
     */
    match /team/{teamMemberId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Secure chat sessions. Access is granted to participants of the chat.
     * @path /chats/{chatId}
     * @allow (get, list) Access to chat if user is a participant.
     * @allow (create) Access to chat if user is a participant.
     * @allow (update) Only participants can update chat metadata (e.g., typing status).
     * @allow (delete) Only participants can delete a chat.
     * @principle Enforces shared access between collaborators.
     */
    match /chats/{chatId} {
      function isParticipant() {
        return request.auth != null && request.auth.uid in resource.data.participants;
      }
       function isExistingParticipant() {
        return request.auth != null && request.auth.uid in resource.data.participants && resource != null;
      }
      allow get: if isParticipant();
      allow list: if false;
      allow create: if request.auth != null && request.auth.uid in request.resource.data.participants;
      allow update: if isExistingParticipant();
      allow delete: if isExistingParticipant();
    }

    /**
     * @description Secure messages within chat sessions. Access is granted to participants of the parent chat.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get, list) Access to messages if user is a participant in the parent chat.
     * @allow (create) Access to messages if user is a participant in the parent chat.
     * @allow (update, delete) No updates or deletions of messages.
     * @principle Enforces shared access between collaborators, inheriting from the parent chat.
     */
    match /chats/{chatId}/messages/{messageId} {
      function isParticipant() {
        return get(/databases/$(database)/documents/chats/$(chatId)).data.participants[request.auth.uid] == true;
      }
      allow get: if isParticipant();
      allow list: if isParticipant();
      allow create: if request.auth != null && isParticipant();
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure user contacts. Only the user can manage their own contacts.
     * @path /users/{userId}/contacts/{contactId}
     * @allow (get, list, create, update, delete) User with matching ID can manage their contacts.
     * @deny (get, list, create, update, delete) User attempts to manage another user's contacts.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/contacts/{contactId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
       function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure group chat sessions. Access is based on group ownership and participants.
     * @path /groups/{groupId}
     * @allow (get, list) Access to group if user is a participant.
     * @allow (create) Only participants can create group chat.
     * @allow (update) Only owner and participants can update group chat metadata.
     * @allow (delete) Only the owner can delete the group.
     * @principle Enforces shared access between collaborators and ownership for administrative tasks.
     */
    match /groups/{groupId} {
      function isParticipant() {
        return request.auth != null && request.auth.uid in resource.data.participants;
      }
      function isOwner() {
        return request.auth != null && request.auth.uid == resource.data.ownerId;
      }
       function isExistingOwner() {
        return isOwner() && resource != null;
      }
      allow get: if isParticipant();
      allow list: if false;
      allow create: if request.auth != null && request.auth.uid in request.resource.data.participants;
      allow update: if isParticipant() || isOwner();
      allow delete: if isExistingOwner();
    }

    /**
     * @description Secure messages within group chat sessions. Access is granted to participants of the parent group.
     * @path /groups/{groupId}/messages/{messageId}
     * @allow (get, list) Access to messages if user is a participant in the parent group.
     * @allow (create) Access to create message if user is a participant in the parent group.
     * @deny (update, delete) No updates or deletions of messages.
     * @principle Enforces shared access between collaborators, inheriting from the parent group.
     */
    match /groups/{groupId}/messages/{messageId} {
      function isParticipant() {
        return get(/databases/$(database)/documents/groups/$(groupId)).data.participants[request.auth.uid] == true;
      }
      allow get: if isParticipant();
      allow list: if isParticipant();
      allow create: if request.auth != null && isParticipant();
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure admin team member list.
     * @path /admin/team
     * @allow (get, list) Public read access to team member profiles.
     * @deny (create, update, delete) Only authenticated team member can manage team member profiles.
     * @principle Restricts write access to authorized users.
     */
     match /admin/team {
          allow get: if true;
          allow list: if true;
          allow create: if false; 
          allow update: if false;
          allow delete: if false;
     }
  }
}